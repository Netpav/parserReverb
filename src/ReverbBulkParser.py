import os
import time
import re
import io # The io module is now recommended instead of codecs and is compatible with Python 3's open syntax, simular module codecs

class ReverbBulkParser(object):
    """Parse Reverb output file and write documents (with class) with added reverb output to file."""

    def __init__(self, remove_duplicates=True, included_phrases='text_triple_std', verbose_output=False):
        """
        :param remove_duplicates (boolean): If triples with same original text should be joined to one document.
        :param verbose (boolean): If final documents should be written to console.
        """
        self.remove_duplicates = remove_duplicates
        self.included_phrases = included_phrases
        self.verbose_output = verbose_output

    def process_file(self, input_filepath, output_dir):
        """
        Read input file, process it (connect sentences to one document) and write result to output file.

        :param input_filepath: Path to the Reverb output file.
        :param output_dir: Path to the output directory.
        :return: nothing
        """
        # Prepare files
        input_file = io.open(input_filepath,'r',encoding='utf8')
        input_filename = os.path.basename(input_filepath).split('.')[0]
        output_filename = input_filename + '_' + self.included_phrases + '.txt'
        output_filepath = os.path.abspath(output_dir + '/' + output_filename)
        # write to utf-8 file
        output_file = io.open(output_filepath,'w',encoding='utf8')
        # Print information
        print('>>>>NEW FILE')
        print('- Reading from file: %s') % input_filepath
        print('- Writing to file: %s') % output_filepath
        start_time = time.time()
        # Read Reverb output line by line.
        n_doc = 0
        # [class, original text, feature1, feature2,...]
        documents = [['0', 'xxx']]
        for r_l_n, r_line in enumerate(input_file, start=1):
            # Get items
            r_items = r_line.split('\t')
            orig_text = r_items[12].strip()
            triple_std = ' '.join(r_items[2:5]).strip()
            triple_normalized = ' '.join(r_items[15:18]).strip()
            # Choose the right triple
            if self.included_phrases in ['text_triple_std', 'triple_std']:
                used_triple = triple_std
            elif self.included_phrases in ['text_triple_norm', 'triple_norm']:
                used_triple = triple_normalized
            # Determined if the triple belongs to current or new document.
            was_new_doc, n_doc, documents = self._process_reverb_text(orig_text, n_doc, documents, used_triple)
            documents[n_doc].append(used_triple)
            # If a new document was created, write the previous one to the file.
            if r_l_n > 1 and was_new_doc:   # skip first line
                self._write_document_to_file(output_file, documents[n_doc - 1])
                # Remove document from list so if there are i.e. 50 000 documents the memory is not full.
                if len(documents) > 4:      # To be sure all methods work :).
                    del(documents[n_doc-1])
                    n_doc -= 1
        # Write last document to the file
        self._write_document_to_file(output_file, documents[n_doc])
        # Show success
        print('>>ALL PROCESSED')
        run_time = time.time() - start_time
        print('>>Script run time for the file: %d seconds') % run_time
        # Clean the mess
        input_file.close()
        output_file.close()

    def _process_reverb_text(self, orig_text, n_doc, documents, triple):
        """
        Process items from reverb line: check if it is a new document.
        If it is, get orig_text and triple (possibly check for duplicates) and create a new document with it inside.
        If it is not, just append text to current document text field.

        :param orig_text: text in reverb line
        :param n_doc: current document number
        :param documents: total list
        :param triple: string generated by Reverb
        :return: If a new document was created, document number, documents list
        """
        # If original text has a number in it, it is a new document.
        split_regex = re.compile('([12])')
        split_text = split_regex.split(orig_text)
        # There is no number.
        if len(split_text) == 1:
            # Add to current document's original text.
            documents[n_doc][1] += ' ' + split_text[0]
            was_new_doc = False
        # There is a number - choose the last item from split.
        else:
            # Get data
            doc_class = split_text[-2]
            doc_text = split_text[-1]
            # If set, check if the original text is the same as previous one. The same for triple.
            if self.remove_duplicates:
                prev_doc_changed = self._check_document_content(doc_text, documents[n_doc], triple)
                if prev_doc_changed:
                    documents[n_doc] = prev_doc_changed
                    return False, n_doc, documents
            # Create a new document.
            n_doc += 1
            documents.append([])
            # Write data to it.
            documents[n_doc].extend([doc_class, doc_text])
            was_new_doc = True
        # result
        return was_new_doc, n_doc, documents

    def _write_document_to_file(self, output_file, document):
        # Write also text?
        if self.included_phrases in ['text_triple_std', 'text_triple_norm']:
            text_line = ' | '.join(document[1:])
        else:
            text_line = ' | '.join(document[2:])
        # Prepare line string
        total_line = document[0] + '\t' + text_line
        # Perform write
        if self.verbose_output:
            print(total_line)
        output_file.write(total_line + '\n')

    def _check_document_content(self, doc_text, previous_doc, triple):
        # Check if the original text is the same as previous one.
        if doc_text == previous_doc[1]:
            # Check if the triple is already in document.
            tr_list = [x for x in previous_doc[2:] if x == triple]
            if tr_list:
                return False  # do nothing
            # If it's not, the tripple will be appended in outer function.
        else:
            return False
        # Result
        return previous_doc
